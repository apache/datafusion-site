<!doctype html>
<html class="no-js" lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Efficient Filter Pushdown in Parquet - Apache DataFusion Blog</title>
<link href="/blog/css/bootstrap.min.css" rel="stylesheet">
<link href="/blog/css/fontawesome.all.min.css" rel="stylesheet">
<link href="/blog/css/headerlink.css" rel="stylesheet">
<link href="/blog/highlight/default.min.css" rel="stylesheet">
<link href="/blog/css/app.css" rel="stylesheet">
<script src="/blog/highlight/highlight.js"></script>
<script>hljs.highlightAll();</script>  </head>
  <body class="d-flex flex-column h-100">
  <main class="flex-shrink-0">
<!-- nav bar -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark" aria-label="Fifth navbar example">
    <div class="container-fluid">
        <a class="navbar-brand" href="/blog"><img src="/blog/images/logo_original4x.png" style="height: 32px;"/> Apache DataFusion Blog</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarADP" aria-controls="navbarADP" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarADP">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="/blog/about.html">About</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="/blog/feed.xml">RSS</a>
                </li>
            </ul>
        </div>
    </div>
</nav>    
<!-- article contents -->
<div id="contents">
  <div class="bg-white p-4 p-md-5 rounded">
    <div class="row justify-content-center">
      <div class="col-12 col-md-8 main-content">
        <h1>
          Efficient Filter Pushdown in Parquet
        </h1>
        <p>Posted on: Fri 21 March 2025 by Xiangpeng Hao</p>

        <aside class="toc-container d-md-none mb-2">
          <div class="toc"><span class="toctitle">Contents</span><ul>
<li><a href="#why-filter-pushdown-in-parquet">Why filter pushdown in Parquet?</a></li>
<li><a href="#how-can-filter-pushdown-be-slower">How can filter pushdown be slower?</a></li>
<li><a href="#attempt-cache-filter-columns">Attempt: cache filter columns</a></li>
<li><a href="#real-solution">Real solution</a><ul>
<li><a href="#what-pages-are-cached">What pages are cached?</a></li>
<li><a href="#then-why-cache-2-pages-per-column-instead-of-1">Then why cache 2 pages per column instead of 1?</a></li>
</ul>
</li>
<li><a href="#how-does-it-perform">How does it perform?</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</div>
        </aside>

        <style>
figure {
  margin: 20px 0;
}

figure img {
  display: block;
  max-width: 80%;
}

figcaption {
  font-style: italic;
  margin-top: 10px;
  color: #555;
  font-size: 0.9em;
  max-width: 80%;
}
</style>
<!--
{% comment %}
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
{% endcomment %}
-->

<p><em>Editor's Note: This blog was first published on <a href="https://blog.xiangpeng.systems/posts/parquet-pushdown/">Xiangpeng Hao's blog</a>. Thanks to <a href="https://www.influxdata.com/">InfluxData</a> for sponsoring this work as part of his PhD funding.</em></p>
<hr/>
<p>In the <a href="https://datafusion.apache.org/blog/2025/03/20/parquet-pruning">previous post</a>, we discussed how <a href="https://datafusion.apache.org/">Apache DataFusion</a> prunes <a href="https://parquet.apache.org/">Apache Parquet</a> files to skip irrelevant <strong>files/row_groups</strong> (sometimes also <a href="https://parquet.apache.org/docs/file-format/pageindex/">pages</a>).</p>
<p>This post discusses how Parquet readers skip irrelevant <strong>rows</strong> while scanning data,
leveraging Parquet's columnar layout by first reading only filter columns,
and then selectively reading other columns only for matching rows.</p>
<h2 id="why-filter-pushdown-in-parquet">Why filter pushdown in Parquet?<a class="headerlink" href="#why-filter-pushdown-in-parquet" title="Permanent link">¶</a></h2>
<p>Below is an example query that reads sensor data with filters on <code>date_time</code> and <code>location</code>.
Without filter pushdown, all rows from <code>location</code>, <code>val</code>, and <code>date_time</code> columns are decoded before <code>location='office'</code> is evaluated. Filter pushdown is especially useful when the filter is selective, i.e., removes many rows.</p>
<pre><code class="language-sql">SELECT val, location 
FROM sensor_data 
WHERE date_time &gt; '2025-03-11' AND location = 'office';
</code></pre>
<figure>
<img alt="Parquet pruning skips irrelevant files/row_groups, while filter pushdown skips irrelevant rows. Without filter pushdown, all rows from location, val, and date_time columns are decoded before `location='office'` is evaluated. Filter pushdown is especially useful when the filter is selective, i.e., removes many rows." class="img-responsive" src="/blog/images/parquet-pushdown/pushdown-vs-no-pushdown.jpg" width="80%"/>
<figcaption>
    Parquet pruning skips irrelevant files/row_groups, while filter pushdown skips irrelevant rows. Without filter pushdown, all rows from location, val, and date_time columns are decoded before `location='office'` is evaluated. Filter pushdown is especially useful when the filter is selective, i.e., removes many rows.
  </figcaption>
</figure>
<p>In our setup, sensor data is aggregated by date — each day has its own Parquet file.
At planning time, DataFusion prunes the unneeded Parquet files, i.e., <code>2025-03-10.parquet</code> and <code>2025-03-11.parquet</code>.</p>
<p>Once the files to read are located, the <a href="https://github.com/apache/datafusion/issues/3463"><em>DataFusion's current default implementation</em></a> reads all the projected columns (<code>sensor_id</code>, <code>val</code>, and <code>location</code>) into Arrow RecordBatches, then applies the filters over <code>location</code> to get the final set of rows.</p>
<p>A better approach is called <strong>filter pushdown</strong> with <strong>late materialization</strong>, which evaluates filter conditions first and only decodes data that passes these conditions.
In practice, this works by first processing only the filter columns (<code>date_time</code> and <code>location</code>), building a boolean mask of rows that satisfy our conditions, then using this mask to selectively decode only the relevant rows from other columns (<code>sensor_id</code>, <code>val</code>). 
This eliminates the waste of decoding rows that will be immediately filtered out.</p>
<p>While simple in theory, practical implementations often make performance worse.</p>
<h2 id="how-can-filter-pushdown-be-slower">How can filter pushdown be slower?<a class="headerlink" href="#how-can-filter-pushdown-be-slower" title="Permanent link">¶</a></h2>
<p>At a high level, the Parquet reader first builds a filter mask -- essentially a boolean array indicating which rows meet the filter criteria -- and then uses this mask to selectively decode only the needed rows from the remaining columns in the projection.</p>
<p>Let's dig into details of <a href="https://github.com/apache/arrow-rs/blob/d5339f31a60a4bd8a4256e7120fe32603249d88e/parquet/src/arrow/async_reader/mod.rs#L618-L712">how filter pushdown is implemented</a> in the current Rust Parquet reader implementation, illustrated in the following figure.</p>
<figure>
<img alt="Implementation of filter pushdown in Rust Parquet readers" class="img-responsive" src="/blog/images/parquet-pushdown/baseline-impl.jpg" with="70%"/>
<figcaption>
    Implementation of filter pushdown in Rust Parquet readers -- the first phase builds the filter mask, the second phase applies the filter mask to the other columns
  </figcaption>
</figure>
<p>The filter pushdown has two phases:</p>
<ol>
<li>
<p>Build the filter mask (steps 1-3)</p>
</li>
<li>
<p>Use the filter mask to selectively decode other columns (steps 4-7), e.g., output step 3 is used as input for step 5 and 7.</p>
</li>
</ol>
<p>Within each phase, it takes three steps from Parquet to Arrow:</p>
<ol>
<li>
<p>Decompress the Parquet pages using generic decompression algorithms like LZ4, Zstd, etc. (steps 1, 4, 6)</p>
</li>
<li>
<p>Decode the page content into Arrow format (steps 2, 5, 7)</p>
</li>
<li>
<p>Evaluate the filter over Arrow data (step 3)</p>
</li>
</ol>
<p>In the figure above, we can see that <code>location</code> is <strong>decompressed and decoded twice</strong>, first when building the filter mask (steps 1, 2), and second when building the output (steps 4, 5).
This happens for all columns that appear both in the filter and output.</p>
<p>The table below shows the corresponding CPU time on the <a href="https://github.com/apache/datafusion/blob/main/benchmarks/queries/clickbench/queries.sql#L23">ClickBench query 22</a>:</p>
<pre><code>+------------+--------+-------------+--------+
| Decompress | Decode | Apply filter| Others |
+------------+--------+-------------+--------+
| 206 ms     | 117 ms | 22 ms       | 48 ms  |
+------------+--------+-------------+--------+
</code></pre>
<p>Clearly, decompress/decode operations dominate the time spent. With filter pushdown, it needs to decompress/decode twice; but without filter pushdown, it only needs to do this once.
This explains why filter pushdown is slower in some cases.</p>
<blockquote>
<p><strong>Note:</strong> Highly selective filters may skip the entire page; but as long as it reads one row from the page, it needs to decompress and often decode the entire page.</p>
</blockquote>
<h2 id="attempt-cache-filter-columns">Attempt: cache filter columns<a class="headerlink" href="#attempt-cache-filter-columns" title="Permanent link">¶</a></h2>
<p>Intuitively, caching the filter columns and reusing them later could help.</p>
<p>But naively caching decoded pages consumes prohibitively high memory:</p>
<ol>
<li>
<p>It needs to cache Arrow arrays, which are on average <a href="https://github.com/XiangpengHao/liquid-cache/blob/main/dev/doc/liquid-cache-vldb.pdf">4x larger than Parquet data</a>.</p>
</li>
<li>
<p>It needs to cache the <strong>entire column chunk in memory</strong>, because in Phase 1 it builds filters over the column chunk, and only use it in Phase 2.  </p>
</li>
<li>
<p>The memory usage is proportional to the number of filter columns, which can be unboundedly high. </p>
</li>
</ol>
<p>Worse, caching filter columns means it needs to read partially from Parquet and partially from cache, which is complex to implement, likely requiring a substantial change to the current implementation. </p>
<blockquote>
<p><strong>Feel the complexity:</strong> consider building a cache that properly handles nested columns, multiple filters, and filters with multiple columns.</p>
</blockquote>
<h2 id="real-solution">Real solution<a class="headerlink" href="#real-solution" title="Permanent link">¶</a></h2>
<p>We need a solution that:</p>
<ol>
<li>
<p>Is simple to implement, i.e., doesn't require thousands of lines of code.</p>
</li>
<li>
<p>Incurs minimal memory overhead.</p>
</li>
</ol>
<p>This section describes my <a href="https://github.com/apache/arrow-rs/pull/6921#issuecomment-2718792433">&lt;700 LOC PR (with lots of comments and tests)</a> that <strong>reduces total ClickBench time by 15%, with up to 2x lower latency for some queries, no obvious regression on other queries, and caches at most 2 pages (~2MB) per column in memory</strong>.</p>
<figure>
<img alt="New decoding pipeline, building filter mask and output columns are interleaved in a single pass, allowing us to cache minimal pages for minimal amount of time" class="img-responsive" src="/blog/images/parquet-pushdown/new-pipeline.jpg" width="80%"/>
<figcaption>
    New decoding pipeline, building filter mask and output columns are interleaved in a single pass, allowing us to cache minimal pages for minimal amount of time
  </figcaption>
</figure>
<p>The new pipeline interleaves the previous two phases into a single pass, so that:</p>
<ol>
<li>
<p>The page being decompressed is immediately used to build filter masks and output columns.</p>
</li>
<li>
<p>Decompressed pages are cached for minimal time; after one pass (steps 1-6), the cache memory is released for the next pass. </p>
</li>
</ol>
<p>This allows the cache to only hold 1 page at a time, and to immediately discard the previous page after it's used, significantly reducing the memory requirement for caching.</p>
<h3 id="what-pages-are-cached">What pages are cached?<a class="headerlink" href="#what-pages-are-cached" title="Permanent link">¶</a></h3>
<p>You may have noticed that only <code>location</code> is cached, not <code>val</code>, because <code>val</code> is only used for output.
More generally, only columns that appear both in the filter and output are cached, and at most 1 page is cached for each such column.</p>
<p>More examples:</p>
<pre><code class="language-sql">SELECT val 
FROM sensor_data 
WHERE date_time &gt; '2025-03-11' AND location = 'office';
</code></pre>
<p>In this case, no columns are cached, because <code>val</code> is not used for filtering.</p>
<pre><code class="language-sql">SELECT COUNT(*) 
FROM sensor_data 
WHERE date_time &gt; '2025-03-11' AND location = 'office';
</code></pre>
<p>In this case, again, no columns are cached, because the output projection is empty after query plan optimization.</p>
<h3 id="then-why-cache-2-pages-per-column-instead-of-1">Then why cache 2 pages per column instead of 1?<a class="headerlink" href="#then-why-cache-2-pages-per-column-instead-of-1" title="Permanent link">¶</a></h3>
<p>This is another real-world nuance regarding how Parquet layouts the pages.</p>
<p>Parquet by default encodes data using <a href="https://parquet.apache.org/docs/file-format/data-pages/encodings/">dictionary encoding</a>, which writes a dictionary page as the first page of a column chunk, followed by the keys referencing the dictionary.</p>
<p>You can see this in action using <a href="https://parquet-viewer.xiangpeng.systems">parquet-viewer</a>:</p>
<figure>
<img alt="Parquet viewer shows the page layout of a column chunk" class="img-responsive" src="/blog/images/parquet-pushdown/parquet-viewer.jpg" width="80%"/>
<figcaption>
    Parquet viewer shows the page layout of a column chunk
  </figcaption>
</figure>
<p>This means that to decode a page of data, it actually references two pages: the dictionary page and the data page.</p>
<p>This is why it caches 2 pages per column: one dictionary page and one data page.
The data page slot will move forward as it reads the data; but the dictionary page slot always references the first page.</p>
<figure>
<img alt="Cached two pages, one for dictionary (pinned), one for data (moves as it reads the data)" class="img-responsive" src="/blog/images/parquet-pushdown/cached-pages.jpg" width="80%"/>
<figcaption>
    Cached two pages, one for dictionary (pinned), one for data (moves as it reads the data)
  </figcaption>
</figure>
<h2 id="how-does-it-perform">How does it perform?<a class="headerlink" href="#how-does-it-perform" title="Permanent link">¶</a></h2>
<p>Here are my results on <a href="https://github.com/apache/datafusion/tree/main/benchmarks#clickbench">ClickBench</a> on my AMD 9900X machine. The total time is reduced by 15%, with Q23 being 2.24x faster,
and queries that get slower are likely due to noise.</p>
<pre><code>┏━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓
┃ Query        ┃ no-pushdown ┃ new-pushdown ┃        Change ┃
┡━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩
│ QQuery 0     │      0.47ms │       0.43ms │ +1.10x faster │
│ QQuery 1     │     51.10ms │      50.10ms │     no change │
│ QQuery 2     │     68.23ms │      64.49ms │ +1.06x faster │
│ QQuery 3     │     90.68ms │      86.73ms │     no change │
│ QQuery 4     │    458.93ms │     458.59ms │     no change │
│ QQuery 5     │    522.06ms │     478.50ms │ +1.09x faster │
│ QQuery 6     │     49.84ms │      49.94ms │     no change │
│ QQuery 7     │     55.09ms │      55.77ms │     no change │
│ QQuery 8     │    565.26ms │     556.95ms │     no change │
│ QQuery 9     │    575.83ms │     575.05ms │     no change │
│ QQuery 10    │    164.56ms │     178.23ms │  1.08x slower │
│ QQuery 11    │    177.20ms │     191.32ms │  1.08x slower │
│ QQuery 12    │    591.05ms │     569.92ms │     no change │
│ QQuery 13    │    861.06ms │     848.59ms │     no change │
│ QQuery 14    │    596.20ms │     580.73ms │     no change │
│ QQuery 15    │    554.96ms │     548.77ms │     no change │
│ QQuery 16    │   1175.08ms │    1146.07ms │     no change │
│ QQuery 17    │   1150.45ms │    1121.49ms │     no change │
│ QQuery 18    │   2634.75ms │    2494.07ms │ +1.06x faster │
│ QQuery 19    │     90.15ms │      89.24ms │     no change │
│ QQuery 20    │    620.15ms │     591.67ms │     no change │
│ QQuery 21    │    782.38ms │     703.15ms │ +1.11x faster │
│ QQuery 22    │   1927.94ms │    1404.35ms │ +1.37x faster │
│ QQuery 23    │   8104.11ms │    3610.76ms │ +2.24x faster │
│ QQuery 24    │    360.79ms │     330.55ms │ +1.09x faster │
│ QQuery 25    │    290.61ms │     252.54ms │ +1.15x faster │
│ QQuery 26    │    395.18ms │     362.72ms │ +1.09x faster │
│ QQuery 27    │    891.76ms │     959.39ms │  1.08x slower │
│ QQuery 28    │   4059.54ms │    4137.37ms │     no change │
│ QQuery 29    │    235.88ms │     228.99ms │     no change │
│ QQuery 30    │    564.22ms │     584.65ms │     no change │
│ QQuery 31    │    741.20ms │     757.87ms │     no change │
│ QQuery 32    │   2652.48ms │    2574.19ms │     no change │
│ QQuery 33    │   2373.71ms │    2327.10ms │     no change │
│ QQuery 34    │   2391.00ms │    2342.15ms │     no change │
│ QQuery 35    │    700.79ms │     694.51ms │     no change │
│ QQuery 36    │    151.51ms │     152.93ms │     no change │
│ QQuery 37    │    108.18ms │      86.03ms │ +1.26x faster │
│ QQuery 38    │    114.64ms │     106.22ms │ +1.08x faster │
│ QQuery 39    │    260.80ms │     239.13ms │ +1.09x faster │
│ QQuery 40    │     60.74ms │      73.29ms │  1.21x slower │
│ QQuery 41    │     58.75ms │      67.85ms │  1.15x slower │
│ QQuery 42    │     65.49ms │      68.11ms │     no change │
└──────────────┴─────────────┴──────────────┴───────────────┘
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━┓
┃ Benchmark Summary           ┃            ┃
┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━┩
│ Total Time (no-pushdown)    │ 38344.79ms │
│ Total Time (new-pushdown)   │ 32800.50ms │
│ Average Time (no-pushdown)  │   891.74ms │
│ Average Time (new-pushdown) │   762.80ms │
│ Queries Faster              │         13 │
│ Queries Slower              │          5 │
│ Queries with No Change      │         25 │
└─────────────────────────────┴────────────┘
</code></pre>
<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">¶</a></h2>
<p>Despite being simple in theory, filter pushdown in Parquet is non-trivial to implement.
It requires understanding both the Parquet format and reader implementation details. 
The challenge lies in efficiently navigating through the dynamics of decoding, filter evaluation, and memory management.</p>
<p>If you are interested in this level of optimization and want to help test, document and implement this type of optimization, come find us in the <a href="https://datafusion.apache.org/contributor-guide/communication.html">DataFusion Community</a>. We would love to have you. </p>

<!--
  Comments Section
  Loaded only after explicit visitor consent to comply with ASF policy.
-->

<div id="comments">
  <hr>
  <h3>Comments</h3>

  <!-- Local loader script -->
  <script src="/content/js/giscus-consent.js" defer></script>

  <!-- Consent UI -->
  <div id="giscus-consent">
    <p>
        We use <a href="https://giscus.app/">Giscus</a> for comments, powered by GitHub Discussions.
        To respect your privacy, Giscus and comments will load only if you click "Show Comments"
    </p>

    <div class="consent-actions">
      <button id="giscus-load" type="button">Show Comments</button>
      <button id="giscus-revoke" type="button" hidden>Hide Comments</button>
    </div>

    <noscript>JavaScript is required to load comments from Giscus.</noscript>
  </div>

  <!-- Container where Giscus will render -->
  <div id="comment-thread"></div>
</div>      </div>
      <aside class="toc-container d-none d-md-block col-md-4 col-xl-3 ms-xl-2">
        <div class="toc"><span class="toctitle">Contents</span><ul>
<li><a href="#why-filter-pushdown-in-parquet">Why filter pushdown in Parquet?</a></li>
<li><a href="#how-can-filter-pushdown-be-slower">How can filter pushdown be slower?</a></li>
<li><a href="#attempt-cache-filter-columns">Attempt: cache filter columns</a></li>
<li><a href="#real-solution">Real solution</a><ul>
<li><a href="#what-pages-are-cached">What pages are cached?</a></li>
<li><a href="#then-why-cache-2-pages-per-column-instead-of-1">Then why cache 2 pages per column instead of 1?</a></li>
</ul>
</li>
<li><a href="#how-does-it-perform">How does it perform?</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</div>
      </aside>
    </div>
  </div>
</div>    
    <!-- footer -->
    <div class="row g-0">
      <div class="col-12">
        <p style="font-style: italic; font-size: 0.8rem; text-align: center;">
          Copyright 2026, <a href="https://www.apache.org/">The Apache Software Foundation</a>, Licensed under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.<br/>
          Apache&reg; and the Apache feather logo are trademarks of The Apache Software Foundation.
        </p>
      </div>
    </div>
    <script src="/blog/js/bootstrap.bundle.min.js"></script>  </main>
  </body>
</html>
