<!doctype html>
<html class="no-js" lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom types in DataFusion using Metadata - Apache DataFusion Blog</title>
<link href="/blog/css/bootstrap.min.css" rel="stylesheet">
<link href="/blog/css/fontawesome.all.min.css" rel="stylesheet">
<link href="/blog/css/headerlink.css" rel="stylesheet">
<link href="/blog/highlight/default.min.css" rel="stylesheet">
<link href="/blog/css/app.css" rel="stylesheet">
<script src="/blog/highlight/highlight.js"></script>
<script>hljs.highlightAll();</script>  </head>
  <body class="d-flex flex-column h-100">
  <main class="flex-shrink-0">
<!-- nav bar -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark" aria-label="Fifth navbar example">
    <div class="container-fluid">
        <a class="navbar-brand" href="/blog"><img src="/blog/images/logo_original4x.png" style="height: 32px;"/> Apache DataFusion Blog</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarADP" aria-controls="navbarADP" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarADP">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="/blog/about.html">About</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="/blog/feed.xml">RSS</a>
                </li>
            </ul>
        </div>
    </div>
</nav>    
<!-- article contents -->
<div id="contents">
  <div class="bg-white p-4 p-md-5 rounded">
    <div class="row justify-content-center">
      <div class="col-12 col-md-8 main-content">
        <h1>
          Custom types in DataFusion using Metadata
        </h1>
        <p>Posted on: Sun 21 September 2025 by Tim Saucer(rerun.io), Dewey Dunnington(Wherobots), Andrew Lamb(InfluxData)</p>

        <aside class="toc-container d-md-none mb-2">
          <div class="toc"><span class="toctitle">Contents</span><ul>
<li><a href="#why-metadata-handling-is-important">Why metadata handling is important</a></li>
<li><a href="#how-to-use-metadata-in-user-defined-functions">How to use metadata in user defined functions</a></li>
<li><a href="#extension-types">Extension types</a></li>
<li><a href="#other-use-cases">Other use cases</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#get-involved">Get Involved</a></li>
</ul>
</div>
        </aside>

        <!--
{% comment %}
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
{% endcomment %}x
-->

<p><a href="https://datafusion.apache.org/blog/2025/07/16/datafusion-48.0.0/">DataFusion 48.0.0</a> introduced a change in the interface for writing custom functions
which enables a variety of interesting improvements. Now users can access metadata on
the input columns to functions and produce metadata in the output.</p>
<p>Metadata is specified as a map of key-value pairs of strings. This extra metadata is used
by Arrow implementations to support <a href="https://arrow.apache.org/docs/format/Columnar.html#format-metadata-extension-types">extension types</a> and can also be used to add
use case-specific context to a column of values where the formality of an extension type
is not required. In previous versions of DataFusion field metadata was propagated through
certain operations (e.g., renaming or selecting a column) but was not accessible to others
(e.g., scalar, window, or aggregate function calls). In the new implementation, during
processing of all user defined functions we pass the input field information and allow
user defined function implementations to return field information to the caller.</p>
<p><a href="https://arrow.apache.org/docs/format/Columnar.html#format-metadata-extension-types">Extension types</a> are user defined data types where the data is stored using one of the
existing <a href="https://arrow.apache.org/docs/format/Columnar.html#data-types">Arrow data types</a> but the metadata specifies how we are to interpret the
stored data. The use of extension types was one of the primary motivations for adding
metadata to the function processing, but arbitrary metadata can be put on the input and
output fields. This allows for a range of other interesting use cases.</p>
<h2 id="why-metadata-handling-is-important">Why metadata handling is important<a class="headerlink" href="#why-metadata-handling-is-important" title="Permanent link">¶</a></h2>
<p>Data in Arrow record batches carry a <code>Schema</code> in addition to the Arrow arrays. Each
<a href="https://arrow.apache.org/docs/format/Glossary.html#term-field">Field</a> in this <code>Schema</code> contains a name, data type, nullability, and metadata. The
metadata is specified as a map of key-value pairs of strings.  In the new
implementation, during processing of all user defined functions we pass the input
field information.</p>
<figure>
<img alt="Relationship between a Record Batch, it's schema, and the underlying arrays. There is a one to one relationship between each Field in the Schema and Array entry in the Columns." class="img-responsive" src="/blog/images/metadata-handling/arrow_record_batch.png" width="100%"/>
<figcaption>
    Relationship between a Record Batch, it's schema, and the underlying arrays. There is a one to one relationship between each Field in the Schema and Array entry in the Columns.
  </figcaption>
</figure>
<p>It is often desirable to write a generic function for reuse. With the prior version of
user defined functions, we only had access to the <code>DataType</code> of the input columns. This
works well for some features that only rely on the types of data. Other use cases may
need additional information that describes the data.</p>
<p>For example, suppose I wish to write a function that takes in a UUID and returns a string
of the <a href="https://www.ietf.org/rfc/rfc9562.html#section-4.1">variant</a> of the input field. We would want this function to be able to handle
all of the string types and also a binary encoded UUID. The arrow specification does not
contain a unsigned 128 bit value, it is common to encode a UUID as a fixed sized binary
array where each element is 16 bytes long. With the metadata handling in <a href="https://datafusion.apache.org/blog/2025/07/16/datafusion-48.0.0/">DataFusion 48.0.0</a>
we can validate during planning that the input data not only has the correct underlying
data type, but that it also represents the right <em>kind</em> of data. The UUID example is a
common one, and it is included in the <a href="https://arrow.apache.org/docs/format/CanonicalExtensions.html">canonical extension types</a> that are now
supported in DataFusion.</p>
<p>Another common application of metadata handling is understanding encoding of a blob of data.
Suppose you have a column that contains image data. Most likely this data is stored as
an array of <code>u8</code> data. Without knowing a priori what the encoding of that blob of data is,
you cannot ensure you are using the correct methods for decoding it. You may work around
this by adding another column to your data source indicating the encoding, but this can be
wasteful for systems where the encoding never changes. Instead, you could use metadata to
specify the encoding for the entire column.</p>
<h2 id="how-to-use-metadata-in-user-defined-functions">How to use metadata in user defined functions<a class="headerlink" href="#how-to-use-metadata-in-user-defined-functions" title="Permanent link">¶</a></h2>
<p>When working with metadata for <a href="https://docs.rs/datafusion/latest/datafusion/logical_expr/trait.ScalarUDFImpl.html">user defined scalar functions</a>, there are typically two
places in the function definition that require implementation.</p>
<ul>
<li>Computing the return field from the arguments</li>
<li>Invocation</li>
</ul>
<p>During planning, we will attempt to call the function <a href="https://docs.rs/datafusion/latest/datafusion/logical_expr/trait.ScalarUDFImpl.html#method.return_field_from_args">return_field_from_args()</a>. This will
provide a list of input fields to the function and return the output field. To evaluate
metadata on the input side, you can write a functions similar to this example:</p>
<pre><code class="language-rust">fn return_field_from_args(
    &amp;self,
    args: ReturnFieldArgs,
) -&gt; datafusion::common::Result&lt;FieldRef&gt; {
    if args.arg_fields.len() != 1 {
        return exec_err!("Incorrect number of arguments for uuid_version");
    }

    let input_field = &amp;args.arg_fields[0];
    if &amp;DataType::FixedSizeBinary(16) == input_field.data_type() {
        let Ok(CanonicalExtensionType::Uuid(_)) = input_field.try_canonical_extension_type()
        else {
            return exec_err!("Input field must contain the UUID canonical extension type");
        };
    }

    let is_nullable = args.arg_fields[0].is_nullable();

    Ok(Arc::new(Field::new(self.name(), DataType::UInt32, is_nullable)))
}
</code></pre>
<p>In this example, we take advantage of the fact that we already have support for extension
types that evaluate metadata. If you were attempting to check for metadata other than
extension type support, we could have instead written a snippet such as:</p>
<pre><code class="language-rust">    if &amp;DataType::FixedSizeBinary(16) == input_field.data_type() {
        let _ = input_field
            .metadata()
            .get("ARROW:extension:metadata")
            .ok_or(exec_datafusion_err!("Input field must contain the UUID canonical extension type"))?;
        };
    }
</code></pre>
<p>If you are writing a user defined function that will instead return metadata on output
you can add this directly into the <code>Field</code> that is the output of the <code>return_field_from_args</code>
call. In our above example, we could change the return line to:</p>
<pre><code class="language-rust">    Ok(Arc::new(
        Field::new(self.name(), DataType::UInt32, is_nullable).with_metadata(
            [("my_key".to_string(), "my_value".to_string())]
                .into_iter()
                .collect(),
        ),
    ))
</code></pre>
<p>By checking the metadata during the planning process, we can identify errors early in
the query process. There are cases were we wish to have access to this metadata during
execution as well. The function <a href="https://docs.rs/datafusion/latest/datafusion/logical_expr/trait.ScalarUDFImpl.html#tymethod.invoke_with_args">invoke_with_args</a> in the user defined function takes
the updated struct <a href="https://docs.rs/datafusion/latest/datafusion/logical_expr/struct.ScalarFunctionArgs.html">ScalarFunctionArgs</a>. This now contains the input fields, which can
be used to check for metadata. For example, you can do the following:</p>
<pre><code class="language-rust">fn invoke_with_args(&amp;self, args: ScalarFunctionArgs) -&gt; Result&lt;ColumnarValue&gt; {
    assert_eq!(args.arg_fields.len(), 1);
    let my_value = args.arg_fields[0]
        .metadata()
        .get("encoding_type");
    ...
</code></pre>
<p>In this snippet we have extracted an <code>Option&lt;String&gt;</code> from the input field metadata
which we can then use to determine which functions we might want to call. We could
then parse the returned value to determine what type of encoding to use when
evaluating the array in the arguments. Since <code>return_field_from_args</code> is not <code>&amp;mut self</code>
this check could not be performed during the planning stage.</p>
<p>The description in this section applies to scalar user defined functions, but equivalent
support exists for aggregate and window functions.</p>
<h2 id="extension-types">Extension types<a class="headerlink" href="#extension-types" title="Permanent link">¶</a></h2>
<p>Extension types are one of the primary motivations for this  enhancement in
<a href="https://datafusion.apache.org/blog/2025/07/16/datafusion-48.0.0/">Datafusion 48.0.0</a>. The official Rust implementation of Apache Arrow, <a href="https://github.com/apache/arrow-rs">arrow-rs</a>,
already contains support for the <a href="https://arrow.apache.org/docs/format/CanonicalExtensions.html">canonical extension types</a>. This support includes
helper functions such as <code>try_canonical_extension_type()</code> in the earlier example.</p>
<p>For a concrete example of how extension types can be used in DataFusion functions,
there is an <a href="https://github.com/timsaucer/datafusion_extension_type_examples">example repository</a> that demonstrates using UUIDs. The UUID extension
type specifies that the data are stored as a Fixed Size Binary of length 16. In the
DataFusion core functions, we have the ability to generate string representations of
UUIDs that match the version 4 specification. These are helpful, but a user may
wish to do additional work with UUIDs where having them in the dense representation
is preferable. Alternatively, the user may already have data with the binary encoding
and we want to extract values such as the version, timestamp, or string
representation.</p>
<p>In the example repository we have created three user defined functions: <code>UuidVersion</code>,
<code>StringToUuid</code>, and <code>UuidToString</code>. Each of these implements <code>ScalarUDFImpl</code> and can
be used thusly:</p>
<pre><code class="language-rust">async fn main() -&gt; Result&lt;()&gt; {
    let ctx = create_context()?;

    // get a DataFrame from the context
    let mut df = ctx.table("t").await?;

    // Create the string UUIDs
    df = df.select(vec![uuid().alias("string_uuid")])?;

    // Convert string UUIDs to canonical extension UUIDs
    let string_to_uuid = ScalarUDF::new_from_impl(StringToUuid::default());
    df = df.with_column("uuid", string_to_uuid.call(vec![col("string_uuid")]))?;

    // Extract version number from canonical extension UUIDs
    let version = ScalarUDF::new_from_impl(UuidVersion::default());
    df = df.with_column("version", version.call(vec![col("uuid")]))?;

    // Convert back to a string
    let uuid_to_string = ScalarUDF::new_from_impl(UuidToString::default());
    df = df.with_column("string_round_trip", uuid_to_string.call(vec![col("uuid")]))?;

    df.show().await?;

    Ok(())
}
</code></pre>
<p>The <a href="https://github.com/timsaucer/datafusion_extension_type_examples">example repository</a> also contains a crate that demonstrates how to expose these
UDFs to <a href="https://datafusion.apache.org/python/">datafusion-python</a>. This requires version 48.0.0 or later.</p>
<h2 id="other-use-cases">Other use cases<a class="headerlink" href="#other-use-cases" title="Permanent link">¶</a></h2>
<p>The metadata attached to the fields can be used to store <em>any</em> user data in key/value
pairs. Some of the other use cases that have been identified include:</p>
<ul>
<li>Creating output for downstream systems. One user of DataFusion produces
  <a href="https://rerun.io/blog/column-chunks">data visualizations</a> that are dependant upon metadata in record batch fields. By
  enabling metadata on output of user defined functions, we can now produce batches
  that are directly consumable by these systems.</li>
<li>Describe the relationships between columns of data. You can store data about how
  one column of data relates to another and use these during function evaluation. For
  example, in robotics it is common to use <a href="https://wiki.ros.org/tf2">transforms</a> to describe how to convert
  from one coordinate system to another. It can be convenient to send the function
  all of the columns that contain transform information and then allow the function
  to determine which columns to use based on the metadata. This allows for
  encapsulation of the transform logic within the user function.</li>
</ul>
<p>Based on the past experience of the authors, we recommend caution when using metadata
for use cases other than type extension. One issue that can arises is that as columns
are used to compute new fields, some functions may pass through the metadata and the
semantic meaning may change. For example, suppose you decided to use metadata to
store some kind of statistics for the entire stream of record batches. Then you pass
that column through a filter that removes many rows of data. Your statistics
metadata may now be invalid, even though it was passed through the filter.</p>
<p>Similarly, if you use metadata to form relations between one column and another and
the naming of the columns has changed at some point in your workflow, then the metadata
may indicate an incorrect column of data it is referring to. This can be mitigated by
not relying on column naming but rather adding additional metadata to all columns of
interest.</p>
<h2 id="acknowledgements">Acknowledgements<a class="headerlink" href="#acknowledgements" title="Permanent link">¶</a></h2>
<p>We would like to thank <a href="https://rerun.io">Rerun.io</a> for sponsoring the development of this work. <a href="https://rerun.io">Rerun.io</a>
is building a data visualization system for Physical AI and uses metadata to specify 
context about columns in Arrow record batches.</p>
<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">¶</a></h2>
<p>The enhancements to the metadata handling in <a href="https://datafusion.apache.org/blog/2025/07/16/datafusion-48.0.0/">DataFusion 48.0.0</a> are a significant step
forward in the ability to handle more interesting types of data. We can validate the input
data matches not only the data types but also the intent of the data to be processed. We
can enable complex operations on binary data because we understand the encoding used. We
can also use metadata to create new and interesting user defined data types.    </p>
<h2 id="get-involved">Get Involved<a class="headerlink" href="#get-involved" title="Permanent link">¶</a></h2>
<p>The DataFusion team is an active and engaging community and we would love to have you join
us and help the project.</p>
<p>Here are some ways to get involved:</p>
<ul>
<li>Learn more by visiting the <a href="https://datafusion.apache.org/index.html">DataFusion</a> project page.</li>
<li>Try out the project and provide feedback, file issues, and contribute code.</li>
<li>Work on a <a href="https://github.com/apache/datafusion/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">good first issue</a>.</li>
<li>Reach out to us via the <a href="https://datafusion.apache.org/contributor-guide/communication.html">communication doc</a>.</li>
</ul>

<!--
  Comments Section
  Loaded only after explicit visitor consent to comply with ASF policy.
-->

<div id="comments">
  <hr>
  <h3>Comments</h3>

  <!-- Local loader script -->
  <script src="/content/js/giscus-consent.js" defer></script>

  <!-- Consent UI -->
  <div id="giscus-consent">
    <p>
        We use <a href="https://giscus.app/">Giscus</a> for comments, powered by GitHub Discussions.
        To respect your privacy, Giscus and comments will load only if you click "Show Comments"
    </p>

    <div class="consent-actions">
      <button id="giscus-load" type="button">Show Comments</button>
      <button id="giscus-revoke" type="button" hidden>Hide Comments</button>
    </div>

    <noscript>JavaScript is required to load comments from Giscus.</noscript>
  </div>

  <!-- Container where Giscus will render -->
  <div id="comment-thread"></div>
</div>      </div>
      <aside class="toc-container d-none d-md-block col-md-4 col-xl-3 ms-xl-2">
        <div class="toc"><span class="toctitle">Contents</span><ul>
<li><a href="#why-metadata-handling-is-important">Why metadata handling is important</a></li>
<li><a href="#how-to-use-metadata-in-user-defined-functions">How to use metadata in user defined functions</a></li>
<li><a href="#extension-types">Extension types</a></li>
<li><a href="#other-use-cases">Other use cases</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#get-involved">Get Involved</a></li>
</ul>
</div>
      </aside>
    </div>
  </div>
</div>    
    <!-- footer -->
    <div class="row g-0">
      <div class="col-12">
        <p style="font-style: italic; font-size: 0.8rem; text-align: center;">
          Copyright 2025, <a href="https://www.apache.org/">The Apache Software Foundation</a>, Licensed under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.<br/>
          Apache&reg; and the Apache feather logo are trademarks of The Apache Software Foundation.
        </p>
      </div>
    </div>
    <script src="/blog/js/bootstrap.bundle.min.js"></script>  </main>
  </body>
</html>
