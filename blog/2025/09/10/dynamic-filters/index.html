<!doctype html>
<html class="no-js" lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Filters: Passing Information Between Operators During Execution for 10x Faster Queries - Apache DataFusion Blog</title>
<link href="/blog/css/bootstrap.min.css" rel="stylesheet">
<link href="/blog/css/fontawesome.all.min.css" rel="stylesheet">
<link href="/blog/css/headerlink.css" rel="stylesheet">
<link href="/blog/highlight/default.min.css" rel="stylesheet">
<link href="/blog/css/app.css" rel="stylesheet">
<script src="/blog/highlight/highlight.js"></script>
<script>hljs.highlightAll();</script>  </head>
  <body class="d-flex flex-column h-100">
  <main class="flex-shrink-0">
<!-- nav bar -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark" aria-label="Fifth navbar example">
    <div class="container-fluid">
        <a class="navbar-brand" href="/blog"><img src="/blog/images/logo_original4x.png" style="height: 32px;"/> Apache DataFusion Blog</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarADP" aria-controls="navbarADP" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarADP">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="/blog/about.html">About</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="/blog/feed.xml">RSS</a>
                </li>
            </ul>
        </div>
    </div>
</nav>    


<!-- article contents -->
<div id="contents">
    <div class="bg-white p-5 rounded">
        <div class="col-md-10 col-lg-8 mx-auto main-content">
          <h1>
            Dynamic Filters: Passing Information Between Operators During Execution for 10x Faster Queries
          </h1>
            <p>Posted on: Wed 10 September 2025 by Adrian Garcia Badaracco (Pydantic), Andrew Lamb (InfluxData)</p>
            <!--
{% comment %}
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
{% endcomment %}
-->
<!-- 
diagrams source: https://docs.google.com/presentation/d/1FFYy27ydZdeFZWWuMjZGnYKUx9QNJfzuVLAH8AE5wlc/edit?slide=id.g364a74cba3d_0_92#slide=id.g364a74cba3d_0_92
Intended Audience: Query engine / data systems developers who want to learn about topk optimization
Goal: Introduce TopK and dynamic filters as in general optimization techniques for query engines, and how they were used to improve performance in DataFusion.
-->
<p>This blog post introduces the query engine optimization techniques called TopK
and dynamic filters. We describe the motivating use case, how these
optimizations work, and how we implemented them with the <a href="https://datafusion.apache.org/">Apache DataFusion</a>
community to support advanced use cases like custom operators and distributed
usage. These optimizations (and related work) have resulted in order of
magnitude improvements for some query patterns.</p>
<h2>Motivation and Results</h2>
<p>The main commercial product at <a href="https://pydantic.dev">Pydantic</a>, <a href="https://pydantic.dev/logfire">Logfire</a> is an observability
platform built on DataFusion. One of the most common workflows / queries is
"show me the last K traces" which translates to a query similar to:</p>
<pre><code class="language-sql">SELECT * FROM records ORDER BY start_timestamp DESC LIMIT 1000;
</code></pre>
<p>We noticed this was <em>pretty slow</em>, even thought DataFusion has long had the
classic <code>TopK</code> optimization (described below). After implementing the
dynamic filter techniques described in this blog, we saw <em>10x and higher
performance improvement</em> for this query pattern, and are applying the
optimization to other queries and operators as well.</p>
<p>Let's look at some preliminary numbers, using <a href="https://github.com/apache/datafusion/blob/main/benchmarks/queries/clickbench/queries/q23.sql">ClickBench</a> which is very similar to our earlier examples:</p>
<pre><code class="language-sql">SELECT * FROM hits WHERE "URL" LIKE '%google%' ORDER BY "EventTime" LIMIT 10;
</code></pre>
<div class="text-center">
<img alt="Q23 Performance Improvement with Dynamic Filters and Late Materialization" class="img-responsive" src="/blog/images/dynamic-filters/execution-time.svg" width="80%"/>
</div>
<p><strong>Figure 1</strong>: Execution times for ClickBench Q23 with and without dynamic
filters (DF)<sup id="fn1"><a href="#footnote1">1</a></sup>, and late materialization
(LM)<sup id="fn2"><a href="#footnote2">2</a></sup> for different partitions / core usage.
Both dynamic filters alone (yellow) and late materialization alone (red) show a
large improvement over the baseline (blue). Combined (green) they show an even
larger improvement, up to a 22x improvement in execution time. See the appendix
for reproduction instructions.</p>
<h2>Background: TopK Optimization</h2>
<p>To explain how dynamic filters improve query performance we first need to
explain the so called "TopK" optimization. To do so we will use a simplified
version of ClickBench Q23:</p>
<pre><code class="language-sql">SELECT * 
FROM hits 
ORDER BY "EventTime"
LIMIT 10
</code></pre>
<p>A straightforward, though slow, plan to answer this query is shown in Figure 2.</p>
<div class="text-center">
<img alt="Naive Query Plan" class="img-responsive" src="/blog/images/dynamic-filters/query-plan-naive.png" width="80%"/>
</div>
<p><strong>Figure 2</strong>: Simple Query Plan for ClickBench Q23. Data flows in plans from the
scan at the bottom to limit at the top. This plan reads all 100M rows of the
<code>hits</code> table, sorts them by <code>EventTime</code>, and then return only the top 10 rows.</p>
<p>This naive plan requires substantial effort: all columns from all rows are
decoded and sorted, but then only 10 are returned. </p>
<p>High performance query engines typically avoid the expensive full sort with a
specialized operator that tracks the current top rows using a <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">heap</a>, rather
than sorting the entire data. For example, this operator
is called <a href="https://docs.rs/datafusion/latest/datafusion/physical_plan/struct.TopK.html">TopK in DataFusion</a>, <a href="https://docs.snowflake.com/en/user-guide/ui-snowsight-activity">SortWithLimit in Snowflake</a>, and <a href="https://duckdb.org/2024/10/25/topn.html#introduction-to-top-n">topn in
DuckDB</a>. The plan for Q23 using this specialized operator is shown in Figure 3.</p>
<div class="text-center">
<img alt="TopK Query Plan" class="img-responsive" src="/blog/images/dynamic-filters/query-plan-topk.png" width="80%"/>
</div>
<p><strong>Figure 3</strong>: Query plan for Q23 in DataFusion using the TopK Operator. This
plan still reads all 100M rows of the <code>hits</code> table, but instead of first sorting
them all by <code>EventTime</code>, the TopK operator keeps track of the current top 10
rows using a Min/Max heap. Credit to <a href="https://visualgo.net/en">Visualgo</a> for the
heap icon</p>
<p>However, this plan still reads and decodes all 100M rows of the <code>hits</code> table,
which is often unnecessary once we have found the top 10 rows. For example,
while running the query, if the current top 10 rows all have <code>EventTime</code> in
2025, then any subsequent rows with <code>EventTime</code> in 2024 or earlier can be
skipped entirely without reading or decoding them. This technique is especially
effective at skipping entire files or row groups if the top 10 values are in the
first few files read, which is very common with timestamp predicates when the
data insert order is approximately the same as the timestamp order.</p>
<p>Leveraging this insight is the key idea behind dynamic filters, which introduce
a runtime mechanism for the TopK operator to provide the current top values to
the scan operator, allowing it to skip unnecessary rows, entire files, or portions
of files. The plan for Q23 with dynamic filters is shown in Figure 4.</p>
<div class="text-center">
<img alt="TopK Query Plan with Dynamic Filters" class="img-responsive" src="/blog/images/dynamic-filters/query-plan-topk-dynamic-filters.png" width="100%"/>
</div>
<p><strong>Figure 4</strong>: Query plan for Q23 in DataFusion with specialized TopK Operator
and dynamic filters. The TopK operator provides the minimum <code>EventTime</code> of the
current top 10 rows to the scan operator, allowing it to skip rows with
<code>EventTime</code> earlier than that value. The scan operator uses this dynamic filter
to skip unnecessary files, and rows, reducing the amount of data that needs to
be read and</p>
<h2>Topk and Dynamic Filters: Example</h2>
<p>To make dynamic filters more concrete let's look at a simplified example. Imagine we
have a table <code>records</code> with a column <code>start_timestamp</code> and we are running the
query from the introduction:</p>
<pre><code class="language-sql">SELECT * 
FROM records 
ORDER BY start_timestamp 
DESC LIMIT 3;
</code></pre>
<p>For example, let's imagine that at some point during execution, the heap in the
<code>TopK</code> operator has the actual 3 most recent values:</p>
<table class="table">
<thead>
<tr>
<th>start_timestamp</th>
</tr>
</thead>
<tbody>
<tr>
<td>2025-08-16T20:35:15.00Z</td>
</tr>
<tr>
<td>2025-08-16T20:35:14.00Z</td>
</tr>
<tr>
<td>2025-08-16T20:35:13.00Z</td>
</tr>
</tbody>
</table>
<p>Since <code>2025-08-16T20:35:13.00Z</code> is the smallest of these values, we know that
any subsequent rows with <code>start_timestamp</code> less than or equal to this value
cannot possibly be in the top 3, and can be skipped entirely.</p>
<p>We can express this condition as a filter of the form <code>start_timestamp &gt;
'2025-08-16T20:35:13.00Z'</code>. If we knew the correct timestamp value before
starting the plan, we could simply write:</p>
<pre><code class="language-sql">SELECT *
FROM records
WHERE start_timestamp &gt; '2025-08-16T20:35:13.00Z'  -- Filter to skip rows
ORDER BY start_timestamp DESC
LIMIT 3;
</code></pre>
<p>And DataFusion's sophisticated <a href="https://datafusion.apache.org/blog/2025/08/15/external-parquet-indexes/">multi-level filter pushdown</a> and pruning would
ensure that we skip reading unnecessary files and row groups, and only decode
the necessary rows.</p>
<p>However, obviously when we start running the query we don't have the value
<code>'2025-08-16T20:35:13.00Z'</code>, so what DataFusion does is put in a placeholder in
the plan, which you can think of as:</p>
<pre><code class="language-sql">SELECT *
FROM records
WHERE dynamic_filter()
ORDER BY start_timestamp DESC
LIMIT 3;
</code></pre>
<p>In this case, <code>dynamic_filter()</code> is a structure that initially has the value
<code>true</code> but will be progressively updated by the TopK operator as the query
progresses. Note that while we are using SQL for illustrative purposes, these
optimizations are actually done at the physical plan ([<code>ExecutionPlan</code>]) layer -
and they apply to both SQL and DataFrame APIs.</p>
<h2>Improving TopK in DataFusion</h2>
<p>As mentioned above, DataFusion has a specialized sort operator named [<code>TopK</code>]
that only keeps ~ <code>K</code> rows in memory. For a <code>DESC</code> sort order, each new input
batch is compared against the current <code>K</code> largest values, and then the current
<code>K</code> rows possibly get replaced with any new rows that were larger. The <a href="https://github.com/apache/datafusion/blob/b4a8b5ae54d939353b7cbd5ab8aee7d3bedecb66/datafusion/physical-plan/src/topk/mod.rs">code is here</a>.</p>
<p>Prior to dynamic filters, DataFusion had no early termination: it would read the
<em>entire</em> <code>records</code> table even if it already had the top <code>K</code> rows because it
still had to check that there were no rows that had larger <code>start_timestamp</code>.</p>
<p>You can see how this is a problem if you have 2 years' worth of timeseries data:
the largest <code>1000</code> values of <code>start_timestamp</code> are likely within the first few
files read, but even if the TopK operator has seen 1000 timestamps on August
16th, 2025, DataFusion would still read files that have only data in 2024 just to
make sure.</p>
<p>InfluxData [optimized a similar query pattern in InfluxDB IOx] using another
operator called [<code>ProgressiveEvalExec</code>] but that operator requires that the data
is already sorted and a careful analysis of ordering to prove that it can be
used. That is not the case for Logfire data (and many other datasets out there):
data can tend to be <em>roughly</em> sorted (e.g. if you append to files as you receive
it) but that does not guarantee that it is fully sorted, including between
files. </p>
<p>We <a href="https://github.com/apache/datafusion/issues/15037">discussed possible solutions</a> with the community, which ultimately resulted
in the implementation of "dynamic filters", and our design is general enough that it
applies to joins as well. We believe our implementation is very similar to
recently announced optimizations in closed source, commercial systems such as
<a href="https://program.berlinbuzzwords.de/bbuzz24/talk/3DTQJB/">Accelerating TopK Queries in Snowflake</a>, or <a href="https://www.alibabacloud.com/blog/about-database-kernel-%7C-learn-about-polardb-imci-optimization-techniques_600274">self-sharpening runtime filters in
Alibaba Cloud's PolarDB</a>, and we are excited we can offer similar performance
improvements in an open source query engine like DataFusion. We hope this will
help all users with similar workloads.</p>
<h2>Implementation for TopK Operator</h2>
<p>TopK operators (a specialization of a sort operator + a limit operator)
implement dynamic filter pushdown by updating a filter each time the heap / TopK
is updated. The filter is then used to skip rows and files during the scan
operator. At the query plan level, Q23 looks like this before it is executed:</p>
<pre><code class="language-text">&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv;       SortExec(TopK)      &boxv;
&boxv;    --------------------   &boxv;
&boxv; EventTime@4 ASC NULLS LAST&boxv;
&boxv;                           &boxv;
&boxv;         limit: 10         &boxv;
&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv;       DataSourceExec      &boxv;
&boxv;    --------------------   &boxv;
&boxv;         files: 100        &boxv;
&boxv;      format: parquet      &boxv;
&boxv;                           &boxv;
&boxv;         predicate:        &boxv;
&boxv; CAST(URL AS Utf8View) LIKE&boxv;
&boxv;      %google% AND true    &boxv;
&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
</code></pre>
<p>You can see the <code>true</code> placeholder filter for the dynamic filter in the
<code>predicate</code> field of the <code>DataSourceExec</code> operator. This will be updated by the
<code>SortExec</code> operator as it processes rows. After running the query, the plan
looks like this, showing the updated filter:</p>
<pre><code class="language-text">&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv;       SortExec(TopK)      &boxv;
&boxv;    --------------------   &boxv;
&boxv; EventTime@4 ASC NULLS LAST&boxv;
&boxv;                           &boxv;
&boxv;         limit: 10         &boxv;
&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv;       DataSourceExec      &boxv;
&boxv;    --------------------   &boxv;
&boxv;         files: 100        &boxv;
&boxv;      format: parquet      &boxv;
&boxv;                           &boxv;
&boxv;         predicate:        &boxv;
&boxv; CAST(URL AS Utf8View) LIKE&boxv;
&boxv;      %google% AND         &boxv;
&boxv; EventTime &lt; 1372713773.0  &boxv;
&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
</code></pre>
<h2>Implementation for Hash Join Operator</h2>
<p>We've also implemented dynamic filters for hash joins, also called "sideways information passing".</p>
<p>In a Hash Join, the query engine picks one side of the join to be the "build" side and the other side to be the "probe" side. The build side is read first and then the probe side is read, using a hash table built from the build side to match rows from the probe side.
Dynamic filters are used to filter the probe side based on the values from the build side.
In particular, we take the min/max values from the build side and use them to create a filter that is applied to the probe side.
This is a very cheap filter to evaluate, but when combined with statistics pruning, late materialization, and other optimizations it can lead to significant performance improvements (we've observed up to 20x improvements in some queries).</p>
<p>A query plan for a hash join with dynamic filters looks like this after it is executed:</p>
<pre><code class="language-sql">copy (select i as k from generate_series(1, 1000) t(i)) to 'small_table.parquet';
copy (select i as k, i as v from generate_series(1, 100000) t(i)) to 'large_table.parquet';
create external table small_table stored as parquet location 'small_table.parquet';
create external table large_table stored as parquet location 'large_table.parquet';
explain select * from small_table join large_table on small_table.k = large_table.k where large_table.v &gt;= 50;
</code></pre>
<pre><code class="language-text">&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv;    CoalesceBatchesExec    &boxv;
&boxv;    --------------------   &boxv;
&boxv;     target_batch_size:    &boxv;
&boxv;            8192           &boxv;
&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv;        HashJoinExec       &boxv;
&boxv;    --------------------   &boxvr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv;        on: (k = k)        &boxv;              &boxv;
&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;              &boxv;
&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;&boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
&boxv;       DataSourceExec      &boxv;&boxv;    CoalesceBatchesExec    &boxv;
&boxv;    --------------------   &boxv;&boxv;    --------------------   &boxv;
&boxv;          files: 1         &boxv;&boxv;     target_batch_size:    &boxv;
&boxv;      format: parquet      &boxv;&boxv;            8192           &boxv;
&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;&boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
                              &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
                              &boxv;         FilterExec        &boxv;
                              &boxv;    --------------------   &boxv;
                              &boxv;     predicate: v &gt;= 50    &boxv;
                              &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
                              &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
                              &boxv;      RepartitionExec      &boxv;
                              &boxv;    --------------------   &boxv;
                              &boxv; partition_count(in-&gt;out): &boxv;
                              &boxv;          1 -&gt; 12          &boxv;
                              &boxv;                           &boxv;
                              &boxv;    partitioning_scheme:   &boxv;
                              &boxv;    RoundRobinBatch(12)    &boxv;
                              &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhd;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
                              &boxdr;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxhu;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxdl;
                              &boxv;       DataSourceExec      &boxv;
                              &boxv;    --------------------   &boxv;
                              &boxv;          files: 1         &boxv;
                              &boxv;      format: parquet      &boxv;
                              &boxv;                           &boxv;
                              &boxv;         predicate:        &boxv;
                              &boxv;      v &gt;= 50 AND.         &boxv;
                              &boxv;     k &gt;= 1 AND k &lt;= 1000  &boxv;
                              &boxur;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxh;&boxul;
</code></pre>
<h2>Implementation for Scan Operator</h2>
<p>Scan operators do not actually know anything about dynamic filters: we were able to package up dynamic filters as an <code>Arc&lt;dyn PhysicalExpr&gt;</code>, which is mostly handled by scan operators like any other expression.
We did, however, add some new functionality to <code>PhysicalExpr</code> to make working with dynamic filters easier:</p>
<ul>
<li><code>PhysicalExpr::generation() -&gt; u64</code>: used to track if a tree of filters has changed (e.g. because it has a dynamic filter that has been updated). For example, if we go from <code>c1 = 'a' AND DynamicFilter [ c2 &gt; 1]</code> to <code>c1 = 'a' AND DynamicFilter [ c2 &gt; 2]</code> the generation value will change so we know if we should re-evaluate the filter against static data like file or row group level statistics. This is used to do early termination of reading a file if the filter is updated mid scan and we can now skip the file, all without needlessly re-evaluating file level statistics all the time.</li>
<li><code>PhysicalExpr::snapshot() -&gt; Arc&lt;dyn PhysicalExpr&gt;</code>: used to create a snapshot of the filter at a given point in time. Dynamic filters use this to return the current value of their inner static filter. This can be used to serialize the filter across the wire in the case of distributed queries or to pass to systems that only support more basic filters (e.g. stats pruning rewrites).</li>
</ul>
<p>This is all encapsulated in the <code>DynamicFilterPhysicalExpr</code> struct.</p>
<p>One of the important design decisions was around directionality of information passing and locking: some early designs had the scan polling the source operators on every row / batch, but this causes a lot of overhead.
Instead, we opted for a "push" based model where the read path has minimal locking and the write path (the TopK operator) is responsible for updating the filter.
Thus, <code>DynamicFilterPhysicalExpr</code> is essentially an <code>Arc&lt;RwLock&lt;Arc&lt;dyn PhysicalExpr&gt;&gt;&gt;</code> which allows the TopK operator to update the filter while the scan operator can read it without blocking.</p>
<h2>Custom <code>ExecutionPlan</code> Operators</h2>
<p>We went to great efforts to ensure that dynamic filters are not a hardcoded black box that only works for internal operators.
The DataFusion community is dynamic and the project is used in many different contexts, some with very advanced custom operators specialized for specific use cases.
To support this, we made sure that dynamic filters can be used with custom <code>ExecutionPlan</code> operators by implementing a couple of methods in the <code>ExecutionPlan</code> trait.
We've made an extensive library of helper structs and functions that make it only 1-2 lines to implement filter pushdown support or a source of dynamic filters for custom operators.</p>
<p>This approach has already paid off: we've had multiple community members implement support for dynamic filter pushdown in just the first few months of this feature being available.</p>
<h2>Future Work</h2>
<p>Although we've made great progress and DataFusion now has one of the most advanced dynamic filter / sideways information passing implementations that we know of, we are not done yet!</p>
<p>There's a multitude of areas of future improvement that we are looking into:</p>
<ul>
<li>Support for more types of joins: we only implemented support for hash inner joins so far. There's the potential to expand this to other join types both in terms of the physical implementation (nested loop joins, etc.) and join type (e.g. left outer joins, cross joins, etc.).</li>
<li>Push down entire hash tables to the scan operator: this could potentially help a lot with join keys that are not naturally ordered or have a lot of skew.</li>
<li>Use file level statistics to order files to match the <code>ORDER BY</code> clause as best we can: this will help TopK dynamic filters be more effective by skipping more work earlier in the scan.</li>
</ul>
<h2>Appendix</h2>
<h3>Queries and Data</h3>
<h4>Figure 1: ClickBench Q23</h4>
<pre><code class="language-sql">-- Data was downloaded using apache/datafusion -&gt; benchmarks/bench.sh -&gt; ./benchmarks/bench.sh data clickbench_partitioned
create external table hits stored as parquet location 'benchmarks/data/hits_partitioned';

-- Must set for ClickBench hits_partitioned dataset. See https://github.com/apache/datafusion/issues/16591
set datafusion.execution.parquet.binary_as_string = true;
-- Only matters if pushdown_filters is enabled but they don't get enabled together sadly
set datafusion.execution.parquet.reorder_filters = true;

set datafusion.execution.target_partitions = 1;  -- or set to 12 to use multiple cores
set datafusion.optimizer.enable_dynamic_filter_pushdown = false;
set datafusion.execution.parquet.pushdown_filters = false;

explain analyze
SELECT *
FROM hits
WHERE "URL" LIKE '%google%'
ORDER BY "EventTime"
LIMIT 10;
</code></pre>
<table class="table">
<thead>
<tr>
<th style="text-align: left;">dynamic filters</th>
<th style="text-align: left;">late materialization</th>
<th style="text-align: right;">cores</th>
<th style="text-align: right;">time (s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">False</td>
<td style="text-align: left;">False</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">32.039</td>
</tr>
<tr>
<td style="text-align: left;">False</td>
<td style="text-align: left;">True</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">16.903</td>
</tr>
<tr>
<td style="text-align: left;">True</td>
<td style="text-align: left;">False</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">18.195</td>
</tr>
<tr>
<td style="text-align: left;">True</td>
<td style="text-align: left;">True</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1.42</td>
</tr>
<tr>
<td style="text-align: left;">False</td>
<td style="text-align: left;">False</td>
<td style="text-align: right;">12</td>
<td style="text-align: right;">5.04</td>
</tr>
<tr>
<td style="text-align: left;">False</td>
<td style="text-align: left;">True</td>
<td style="text-align: right;">12</td>
<td style="text-align: right;">2.37</td>
</tr>
<tr>
<td style="text-align: left;">True</td>
<td style="text-align: left;">False</td>
<td style="text-align: right;">12</td>
<td style="text-align: right;">5.055</td>
</tr>
<tr>
<td style="text-align: left;">True</td>
<td style="text-align: left;">True</td>
<td style="text-align: right;">12</td>
<td style="text-align: right;">0.602</td>
</tr>
</tbody>
</table>
<h2>About the Authors</h2>
<p><a href="https://www.linkedin.com/in/adrian-garcia-badaracco/">Adrian Garcia Badaracco</a> is a Founding Engineer at
<a href="https://pydantic.dev/">Pydantic</a>, and an <a href="https://datafusion.apache.org/">Apache
DataFusion</a> committer. </p>
<p><a href="https://www.linkedin.com/in/andrewalamb/">Andrew Lamb</a> is a Staff Engineer at
<a href="https://www.influxdata.com/">InfluxData</a>, and a member of the <a href="https://datafusion.apache.org/">Apache
DataFusion</a> and <a href="https://arrow.apache.org/">Apache Arrow</a> PMCs. He has been working on
databases and related systems for more than 20 years.</p>
<h2>About DataFusion</h2>
<p><a href="https://datafusion.apache.org/">Apache DataFusion</a> is an extensible query engine toolkit, written
in Rust, that uses <a href="https://arrow.apache.org/">Apache Arrow</a> as its in-memory format. DataFusion and
similar technology are part of the next generation &ldquo;Deconstructed Database&rdquo;
architectures, where new systems are built on a foundation of fast, modular
components, rather than as a single tightly integrated system.</p>
<p>The <a href="https://datafusion.apache.org/contributor-guide/communication.html">DataFusion community</a> is always looking for new contributors to help
improve the project. If you are interested in learning more about how query
execution works, help document or improve the DataFusion codebase, or just try
it out, we would love for you to join us.</p>
<h2>Footnotes</h2>
<p><a id="footnote1"></a><sup><a href="#fn1">1</a></sup> <em>Dynamic Filters (DF)</em> refers to the
optimization described in this blog post. The TopK operator will generate a
filter that is applied to the scan operators, which will first be used to skip
rows and then as we open new files (if there are more to open) it will be used
to skip entire files that do not match the filter.</p>
<p><a id="footnote2"></a><sup><a href="#fn2">2</a></sup> <em>Late Materialization (LM)</em> refers to
the optimization described in <a href="https://datafusion.apache.org/blog/2025/03/21/parquet-pushdown/">this blog post</a>. Late Materialization is
particularly effective when combined with dynamic filters as it can apply
filters during a scan. Without late materialization, dynamic filters can only be
used to prune row groups or entire files, which will be less effective if the 
files themselves are large or the top values are not in the first few files read.</p>

    <!--
        Enable giscuss comments: Allows comments on the blogs posted as
        https://github.com/apache/datafusion-site/discussions

        More details on https://github.com/apache/datafusion-site/issues/80
    -->
    <div id="article_comments">
        <div id="comment_thread"></div>

        <script src="https://giscus.app/client.js"
            data-repo="apache/datafusion-site"
            data-repo-id="R_kgDOL8FTzw"
            data-category="Announcements"
            data-category-id="DIC_kwDOL8FTz84Csqua"
            data-mapping="title"
            data-strict="1"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
        </script>
    </div>          </div>
      </div>
    </div>    
    <!-- footer -->
    <div class="row g-0">
      <div class="col-12">
        <p style="font-style: italic; font-size: 0.8rem; text-align: center;">
          Copyright 2025, <a href="https://www.apache.org/">The Apache Software Foundation</a>, Licensed under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.<br/>
          Apache&reg; and the Apache feather logo are trademarks of The Apache Software Foundation.
        </p>
      </div>
    </div>
    <script src="/blog/js/bootstrap.bundle.min.js"></script>  </main>
  </body>
</html>
