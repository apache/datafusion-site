<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Apache DataFusion Blog - Tim Saucer, Dewey Dunnington, Andrew Lamb</title><link href="https://datafusion.apache.org/blog/" rel="alternate"></link><link href="https://datafusion.apache.org/blog/feeds/tim-saucer-dewey-dunnington-andrew-lamb.atom.xml" rel="self"></link><id>https://datafusion.apache.org/blog/</id><updated>2025-06-09T00:00:00+00:00</updated><subtitle></subtitle><entry><title>Field metadata and extension type support in user defined functions</title><link href="https://datafusion.apache.org/blog/2025/06/09/metadata-handling" rel="alternate"></link><published>2025-06-09T00:00:00+00:00</published><updated>2025-06-09T00:00:00+00:00</updated><author><name>Tim Saucer, Dewey Dunnington, Andrew Lamb</name></author><id>tag:datafusion.apache.org,2025-06-09:/blog/2025/06/09/metadata-handling</id><summary type="html">&lt;!--
{% comment %}
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
{% endcomment %}x
--&gt;
&lt;p&gt;&lt;a href="https://datafusion.apache.org/blog/2025/07/16/datafusion-48.0.0/"&gt;DataFusion 48.0.0&lt;/a&gt; introduced a change in the interface for writing custom functions
which enables a variety of interesting improvements. Now users can access metadata on
the input columns to functions and produce metadata in the output.&lt;/p&gt;
&lt;p&gt;Metadata is specified as a map of key-value pairs of strings. This â€¦&lt;/p&gt;</summary><content type="html">&lt;!--
{% comment %}
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
{% endcomment %}x
--&gt;
&lt;p&gt;&lt;a href="https://datafusion.apache.org/blog/2025/07/16/datafusion-48.0.0/"&gt;DataFusion 48.0.0&lt;/a&gt; introduced a change in the interface for writing custom functions
which enables a variety of interesting improvements. Now users can access metadata on
the input columns to functions and produce metadata in the output.&lt;/p&gt;
&lt;p&gt;Metadata is specified as a map of key-value pairs of strings. This extra metadata is used
by Arrow implementations implement &lt;a href="https://arrow.apache.org/docs/format/Columnar.html#format-metadata-extension-types"&gt;extension types&lt;/a&gt; and can also be used to add
use case-specific context to a column of values where the formality of an extension type
is not required. In previous versions of DataFusion field metadata was propagated through
certain operations (e.g., renaming or selecting a column) but was not accessible to others
(e.g., scalar, window, or aggregate function calls). In the new implementation, during
processing of all user defined functions we pass the input field information and allow
user defined function implementations to return field information to the caller.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://arrow.apache.org/docs/format/Columnar.html#format-metadata-extension-types"&gt;Extension types&lt;/a&gt; are user defined data types where the data is stored using one of the
existing &lt;a href="https://arrow.apache.org/docs/format/Columnar.html#data-types"&gt;Arrow data types&lt;/a&gt; but the metadata specifies how we are to interpret the
stored data. The use of extension types was one of the primary motivations for adding
metadata to the function processing, but arbitrary metadata can be put on the input and
output fields. This allows for a range of other interesting use cases.&lt;/p&gt;
&lt;h2&gt;Why metadata handling is important&lt;/h2&gt;
&lt;p&gt;Data in Arrow record batches carry a &lt;code&gt;Schema&lt;/code&gt; in addition to the Arrow arrays. Each
&lt;a href="https://arrow.apache.org/docs/format/Glossary.html#term-field"&gt;Field&lt;/a&gt; in this &lt;code&gt;Schema&lt;/code&gt; contains a name, data type, nullability, and metadata. The
metadata is specified as a map of key-value pairs of strings.  In the new
implementation, during processing of all user defined functions we pass the input
field information.&lt;/p&gt;
&lt;figure&gt;
&lt;img alt="Relationship between a Record Batch, it's schema, and the underlying arrays. There is a one to one relationship between each Field in the Schema and Array entry in the Columns." class="img-responsive" src="/blog/images/metadata-handling/arrow_record_batch.png" width="100%"/&gt;
&lt;figcaption&gt;
    Relationship between a Record Batch, it's schema, and the underlying arrays. There is a one to one relationship between each Field in the Schema and Array entry in the Columns.
  &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;It is often desirable to write a generic function for reuse. With the prior version of
user defined functions, we only had access to the &lt;code&gt;DataType&lt;/code&gt; of the input columns. This
works well for some features that only rely on the types of data. Other use cases may
need additional information that describes the data.&lt;/p&gt;
&lt;p&gt;For example, suppose I wish to write a function that takes in a UUID and returns a string
of the &lt;a href="https://www.ietf.org/rfc/rfc9562.html#section-4.1"&gt;variant&lt;/a&gt; of the input field. We would want this function to be able to handle
all of the string types and also a binary encoded UUID. The arrow specification does not
contain a unsigned 128 bit value, it is common to encode a UUID as a fixed sized binary
array where each element is 16 bytes long. With the metadata handling in &lt;a href="https://datafusion.apache.org/blog/2025/07/16/datafusion-48.0.0/"&gt;DataFusion 48.0.0&lt;/a&gt;
we can validate during planning that the input data not only has the correct underlying
data type, but that it also represents the right &lt;em&gt;kind&lt;/em&gt; of data. The UUID example is a
common one, and it is included in the &lt;a href="https://arrow.apache.org/docs/format/CanonicalExtensions.html"&gt;canonical extension types&lt;/a&gt; that are now
supported in DataFusion.&lt;/p&gt;
&lt;p&gt;Another common application of metadata handling is understanding encoding of a blob of data.
Suppose you have a column that contains image data. Most likely this data is stored as
an array of &lt;code&gt;u8&lt;/code&gt; data. Without knowing a priori what the encoding of that blob of data is,
you cannot ensure you are using the correct methods for decoding it. You may work around
this by adding another column to your data source indicating the encoding, but this can be
wasteful for systems where the encoding never changes. Instead, you could use metadata to
specify the encoding for the entire column.&lt;/p&gt;
&lt;h2&gt;How to use metadata in user defined functions&lt;/h2&gt;
&lt;p&gt;When working with metadata for user defined scalar functions, there are typically two
places in the function definition that require implementation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Computing the return field from the arguments&lt;/li&gt;
&lt;li&gt;Invocation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;During planning, we will attempt to call the function &lt;code&gt;return_field_from_args()&lt;/code&gt;. This will
provide a list of input fields to the function and return the output field. To evaluate
metadata on the input side, you can write a functions similar to this example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rust"&gt;fn return_field_from_args(
    &amp;amp;self,
    args: ReturnFieldArgs,
) -&amp;gt; datafusion::common::Result&amp;lt;FieldRef&amp;gt; {
    if args.arg_fields.len() != 1 {
        return exec_err!("Incorrect number of arguments for uuid_version");
    }

    let input_field = &amp;amp;args.arg_fields[0];
    if &amp;amp;DataType::FixedSizeBinary(16) == input_field.data_type() {
        let Ok(CanonicalExtensionType::Uuid(_)) = input_field.try_canonical_extension_type()
        else {
            return exec_err!("Input field must contain the UUID canonical extension type");
        };
    }

    Ok(Arc::new(Field::new(self.name(), DataType::UInt32, true)))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we take advantage of the fact that we already have support for extension
types that evaluate metadata. If you were attempting to check for metadata other than
extension type support, we could have instead written a snippet such as:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rust"&gt;    if &amp;amp;DataType::FixedSizeBinary(16) == input_field.data_type() {
        let _ = input_field
            .metadata()
            .get("ARROW:extension:metadata")
            .ok_or(exec_datafusion_err!("Input field must contain the UUID canonical extension type"))?;
        };
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are writing a user defined function that will instead return metadata on output
you can add this directly into the &lt;code&gt;Field&lt;/code&gt; that is the output of the &lt;code&gt;return_field_from_args&lt;/code&gt;
call. In our above example, we could change the return line to:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rust"&gt;    Ok(Arc::new(
        Field::new(self.name(), DataType::UInt32, true).with_metadata(
            [("my_key".to_string(), "my_value".to_string())]
                .into_iter()
                .collect(),
        ),
    ))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By checking the metadata during the planning process, we can identify errors early in
the query process. There are cases were we wish to have access to this metadata during
execution as well. The function &lt;code&gt;invoke_with_args&lt;/code&gt; in the user defined function takes
the updated struct &lt;code&gt;ScalarFunctionArgs&lt;/code&gt;. This now contains the input fields, which can
be used to check for metadata. For example, you can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rust"&gt;fn invoke_with_args(&amp;amp;self, args: ScalarFunctionArgs) -&amp;gt; Result&amp;lt;ColumnarValue&amp;gt; {
    assert_eq!(args.arg_fields.len(), 1);
    let my_value = args.arg_fields[0]
        .metadata()
        .get("encoding_type");
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this snippet we have extracted an &lt;code&gt;Option&amp;lt;String&amp;gt;&lt;/code&gt; from the input field metadata
which we can then use to determine which functions we might want to call. We could
then parse the returned value to determine what type of encoding to use when
evaluating the array in the arguments. Since &lt;code&gt;return_field_from_args&lt;/code&gt; is not &lt;code&gt;&amp;amp;mut self&lt;/code&gt;
this check could not be performed during the planning stage.&lt;/p&gt;
&lt;p&gt;The description in this section applies to scalar user defined functions, but equivalent
support exists for aggregate and window functions.&lt;/p&gt;
&lt;h2&gt;Extension types&lt;/h2&gt;
&lt;p&gt;Extension types are one of the primary motivations for this  enhancement in
&lt;a href="https://datafusion.apache.org/blog/2025/07/16/datafusion-48.0.0/"&gt;Datafusion 48.0.0&lt;/a&gt;. The official Rust implementation of Apache Arrow, &lt;a href="https://github.com/apache/arrow-rs"&gt;arrow-rs&lt;/a&gt;,
already contains support for the &lt;a href="https://arrow.apache.org/docs/format/CanonicalExtensions.html"&gt;canonical extension types&lt;/a&gt;. This support includes
helper functions such as &lt;code&gt;try_canonical_extension_type()&lt;/code&gt; in the earlier example.&lt;/p&gt;
&lt;p&gt;For a concrete example of how extension types can be used in DataFusion functions,
there is an &lt;a href="https://github.com/timsaucer/datafusion_extension_type_examples"&gt;example repository&lt;/a&gt; that demonstrates using UUIDs. The UUID extension
type specifies that the data are stored as a Fixed Size Binary of length 16. In the
DataFusion core functions, we have the ability to generate string representations of
UUIDs that match the version 4 specification. These are helpful, but a user may
wish to do additional work with UUIDs where having them in the dense representation
is preferable. Alternatively, the user may already have data with the binary encoding
and we want to extract values such as the version, timestamp, or string
representation.&lt;/p&gt;
&lt;p&gt;In the example repository we have created three user defined functions: &lt;code&gt;UuidVersion&lt;/code&gt;,
&lt;code&gt;StringToUuid&lt;/code&gt;, and &lt;code&gt;UuidToString&lt;/code&gt;. Each of these implements &lt;code&gt;ScalarUDFImpl&lt;/code&gt; and can
be used thusly:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rust"&gt;async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {
    let ctx = create_context()?;

    // get a DataFrame from the context
    let mut df = ctx.table("t").await?;

    // Create the string UUIDs
    df = df.select(vec![uuid().alias("string_uuid")])?;

    // Convert string UUIDs to canonical extension UUIDs
    let string_to_uuid = ScalarUDF::new_from_impl(StringToUuid::default());
    df = df.with_column("uuid", string_to_uuid.call(vec![col("string_uuid")]))?;

    // Extract version number from canonical extension UUIDs
    let version = ScalarUDF::new_from_impl(UuidVersion::default());
    df = df.with_column("version", version.call(vec![col("uuid")]))?;

    // Convert back to a string
    let uuid_to_string = ScalarUDF::new_from_impl(UuidToString::default());
    df = df.with_column("string_round_trip", uuid_to_string.call(vec![col("uuid")]))?;

    df.show().await?;

    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href="https://github.com/timsaucer/datafusion_extension_type_examples"&gt;example repository&lt;/a&gt; also contains a crate that demonstrates how to expose these
UDFs to &lt;a href="https://datafusion.apache.org/python/"&gt;datafusion-python&lt;/a&gt;. This requires version 48.0.0 or later.&lt;/p&gt;
&lt;h2&gt;Thanks to our sponsor&lt;/h2&gt;
&lt;p&gt;We would like to thank &lt;a href="https://rerun.io"&gt;Rerun.io&lt;/a&gt; for sponsoring the development of this work. &lt;a href="https://rerun.io"&gt;Rerun.io&lt;/a&gt;
is building a data visualization system for Physical AI and uses metadata to specify 
context about columns in Arrow record batches.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The enhancements to the metadata handling in &lt;a href="https://datafusion.apache.org/blog/2025/07/16/datafusion-48.0.0/"&gt;DataFusion 48.0.0&lt;/a&gt; are a significant step
forward in the ability to handle more interesting types of data. We can validate the input
data matches not only the data types but also the intent of the data to be processed. We
can enable complex operations on binary data because we understand the encoding used. We
can also use metadata to create new and interesting user defined data types.    &lt;/p&gt;
&lt;h2&gt;Get Involved&lt;/h2&gt;
&lt;p&gt;The DataFusion team is an active and engaging community and we would love to have you join
us and help the project.&lt;/p&gt;
&lt;p&gt;Here are some ways to get involved:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Learn more by visiting the &lt;a href="https://datafusion.apache.org/index.html"&gt;DataFusion&lt;/a&gt; project page.&lt;/li&gt;
&lt;li&gt;Try out the project and provide feedback, file issues, and contribute code.&lt;/li&gt;
&lt;li&gt;Work on a &lt;a href="https://github.com/apache/datafusion/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22"&gt;good first issue&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Reach out to us via the &lt;a href="https://datafusion.apache.org/contributor-guide/communication.html"&gt;communication doc&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</content><category term="blog"></category></entry></feed>